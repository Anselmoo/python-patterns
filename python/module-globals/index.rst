
================
 Module Globals
================

*A “Creational Pattern” inspired by Modula-2 and Modula-3*

.. admonition:: Verdict

   The Module Global pattern is the universal mechanism
   by which a Python module offers functions, classes, constants,
   pre-built objects, and metadata
   for other modules to import.
   This pattern was not available
   in the programming languages considered by the :doc:`/gang-of-four/index`,
   which instead offered only program-wide globals —
   which the Gang of Four condemns as an anti-pattern
   and recommends the Singleton Pattern instead.

.. TODO Add this one I do the singleton:
   Module globals are more common in Python
   than the Gang of Four’s :doc:`gang-of-four/singleton`,
   which was a trick to avoid creating any more global names than necessary
   in languages without the benefit of a module system.

.. TODO mention how for verbs, not nouns, we put methods in the global
   namespace; exmaples are random and json modules

Every Python module is a separate namespace.
Thus, a module like ``json`` can offer a ``loads()`` function
without conflicting with, replacing, or overwriting
the completely different ``loads()`` function
defined over in the ``pickle`` module.

Separate namespaces are crucial to making a programming language tractable.
If Python modules were not separate namespaces,
you would be unable to read or write Python code
by keeping your attention focused on the module in front of you —
a line of code might use, or accidentally conflict with,
a name defined anywhere else in the Standard Library
or a third-party module you have installed.
Programmers forced to code in a language without namespaces
soon find themselves festooning names
with prefixes, suffixes, and extra punctuation
in a desperate race to keep names from conflicting
with similar names defined in other files and libraries.

While every function and class defined in a module is,
technically, an object,
and therefore an example of a Module Global,
the pattern more specifically refers to objects created at the module level
besides those generated by syntactic blocks of code.

Two patterns use Module Globals
but are important enough to have warranted their own articles:

* :doc:`/python/prebound-methods/index`
  are generated when a module builds an object
  and then assigns one or more of the object’s bound methods
  to names at the module’s global level.
  The names can be used to call the methods later
  without needing to know the name of the object itself.

* While a :doc:`/python/sentinel-object/index` is not required
  to live at the module level —
  some sentinel objects are defined as class attributes,
  while others are private and live inside of a closure —
  many sentinels, both in the Standard Library and beyond,
  are defined and accessed as module globals.

This article will cover some other common cases.

.. underscore ForkingPickler = context.reduction.ForkingPickler

Constants
=========

Modules often assign useful numbers, strings, and other values
to names in their global scope.
The Standard Library includes many such assignments,
from which we can excerpt a few examples.

  January = 1                   # calendar.py
  WARNING = 30                  # logging.py
  MAX_INTERPOLATION_DEPTH = 10  # configparser.py
  SSL_HANDSHAKE_TIMEOUT = 60.0  # asyncio.constants.py
  TICK = "'"                    # email.utils.py
  CRLF = "\r\n"                 # smtplib.py

They are “constants” only in the sense
that the objects themselves are immutable.
The names can still be reassigned.

.. testcode::

   import calendar
   calendar.January = 13
   print(calendar.January)

.. testoutput::

   13

Or deleted, for that matter.

.. testcode::

   del calendar.January
   print(calendar.January)

.. testoutput::

    Traceback (most recent call last):
      ..
    AttributeError: module 'calendar' has no attribute 'January'

In addition to integers, floats, and strings,
values are also crafted from immutable containers like tuples and frozen sets::

  all_errors = (Error, OSError, EOFError)  # ftplib.py
  bytes_types = (bytes, bytearray)         # pickle.py
  DIGITS = frozenset("0123456789")         # sre_parse.py

Even more specialized immutable data types also serve as constants:

  _EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)  # datetime

On rare occasion a module global
which the code clearly intends to never modify
uses a mutable data structure anyway.
Sets are common in code that pre-dates the invention of the ``frozenset``,
while dictionaries are still used today
because, alas, no frozen dictionary exists in Python.

::

  # socket.py
  _blocking_errnos = { EAGAIN, EWOULDBLOCK }

::

  # locale.py
  windows_locale = {
    0x0436: "af_ZA", # Afrikaans
    0x041c: "sq_AL", # Albanian
    0x0484: "gsw_FR",# Alsatian - France
    ...
    0x0435: "zu_ZA", # Zulu
  }

Constants are often introduced as a refactoring:
the programmer notices that the same value ``60.0``
is appearing repeatedly in their code,
and so introduces a constant ``SSL_HANDSHAKE_TIMEOUT``
for the value instead.
Each use will now incur the slight cost of search into the global scope
where an immediate literal value stood before,
but this is balanced by a couple of advantages.
The constant’s name now documents the value’s meaning,
enhancing the code’s readability.
And the constant’s assignment statement
now provides a single location
where the value can be edited in the future
without needing to hunt through the code for each place ``60.0`` was used.

These advantages are weighty enough
that a constant is sometimes introduced
even for a value that’s used only once,
hoisting a literal that was hidden deep in the code
up into visibility as a global.

Some programmers place constant assignments
close to the code that use them,
while others them all at the top of the file.
Unless a constant is placed so close to its code
that it will always be in view of human readers,
it can be more friendly to put constants at the top of the module
for the easy reference of readers
who haven’t yet configured their editors to support jump-to-definition.

Another kind of constant is not directed inwards,
towards the code in the module itself,
but outwards as part of the module’s advertised API.
A constant like ``WARNING`` from the ``logging`` module
offers the advantages of a constant to the caller:
code will be more readable,
and the constant’s value could be adjusted later
without every caller needing to edit their code.

You might expect that a constant intended for the module’s own use,
but not intended for callers,
would always start with an underscore to mark it as private.
But the cost of needing to keep a constant around
because a caller decided to start using it is small
compared to the cost of having a function or class’s API forever locked up,
so Python programmers are not as consistent in marking constants private.

Sometimes constants are introduced for efficiency,
to avoid recomputing a value every time code is called.
Even though math operations involving literal numbers
are in fact pre-computed in all modern Python implementations,
developers often still feel more comfortable
making it explicit that the math should be done at import time
by assignment to a module global::

  # zipfile.py
  ZIP_FILECOUNT_LIMIT = (1 << 16) - 1

When the math expression is complicated,
assigning a name like this can also enhance the code’s readability.

There exist special floating point values
that cannot be written in Python as literals;
they can only be generated by passing a string to the float type.
To avoid calling ``float()`` with ``'nan'`` or ``'inf'``
every single time such a value is needed,
modules often build such values only once as module globals.

::

  # encoder.py
  INFINITY = float('inf')

A constant can also capture the result of a conditional
to avoid re-evaluating it each time the value is needed.

::

  # shutil.py
  COPY_BUFSIZE = 1024 * 1024 if _WINDOWS else 16 * 1024

My favorite example of computed constants in the Standard Library
is the ``types`` module.
I had always assumed it implemented in C,
to gain special access to built-in type objects like ``FunctionType``
and ``LambdaType`` that are defined by the language implementation itself.

It turns out?
I was wrong.

The ``types`` module is written in plain Python.
Without any special access to language internals,
it does what anyone else would have to do
to learn what type functions have.
It creates a function. Then, it asks its type!

::

  # types.py
  def _f(): pass
  FunctionType = type(_f)

On the one hand,
this makes the ``types`` module seem almost superfluous —
you could always use the same trick to discover ``FunctionType`` yourself.
But on the other hand,
importing it from ``types`` lets both major benefits of the constant shine:
code becomes more readable,
because ``FunctionType`` will have the same name everywhere;
and more efficient,
because the constant only needs to be computed once
no matter how many dozen modules in a large system might use it.

constant collections
====================

File: Parser/asdl.py
builtin_types = {'identifier', 'string', 'bytes', 'int', 'object', 'singleton',

File: Lib/asyncore.py
60:1:_DISCONNECTED = frozenset({ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE,

Lib/asyncore.py
60:1:_DISCONNECTED = frozenset({ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE,
^ differing levels of effort to make it constant

shutil.py
585:1:_use_fd_functions = ({os.open, os.stat, os.unlink, os.rmdir} <=
                     os.supports_dir_fd and
                     os.scandir in os.supports_fd and
                     os.stat in os.supports_follow_symlinks)
BARELY made sense

Precompiled globals
===================

compile re’s once
File: Lib/glob.py
142:1:magic_check = re.compile('([*?[])')

File: Lib/email/policy.py
23:1:linesep_splitter = re.compile(r'\n|\r')

File: Lib/signal.py
6:1:_globals = globals()

File: Lib/email/header.py
31:1:USASCII = Charset('us-ascii')

File: Lib/re.py
262:1:Pattern = type(sre_compile.compile('', 0))
263:1:Match = type(sre_compile.compile('', 0).match(''))

dunder constants
================

dunder metadata

__all__
__author__
__version__
_ver

File: Lib/unittest/test/testmock/__init__.py
6:1:here = os.path.dirname(__file__)
^ is this anywhere non-test?


File: Lib/xdrlib.py
__all__ = ["Error", "Packer", "Unpacker", "ConversionError"]

File: Lib/__future__.py
50:1:all_feature_names = [
63:1:__all__ = ["all_feature_names"] + all_feature_names
128:1:print_function = _Feature((2, 6, 0, "alpha", 2),
??

not constant at all
not only can you reassign, BUT often not even immutable data structs
why list?
doing tuple for all saves at least 16 bytes? and level of indirection
File: Lib/multiprocessing/context.py
8:1:__all__ = ()

Lib/asyncio/*.py use tuple for all
File: Lib/contextvars.py
4:1:__all__ = ('Context', 'ContextVar', 'Token', 'copy_context')
File: Lib/concurrent/futures/__init__.py
20:1:__all__ = (

File: Lib/tkinter/font.py
6:1:__version__ = "0.9"

File: Lib/turtle.py
103:1:_ver = "turtle 1.1b- - for Python 3.1   -  4. 5. 2009"

but should it be tuple or string?

File: Lib/bz2.py
10:1:__author__ = "Nadeem Vawda <nadeem.vawda@gmail.com>"

__author__ = ("Guido van Rossum <guido@python.org>, "

/home/brandon/cpython/Lib/_collections_abc.py
27:__name__ = "collections.abc"

mutable globals
===============

everything is an object BUT I MEAN:

Pattern - “singleton” object

File: Lib/os.py
759:1:environ = _createenviron()

217:1:default = EmailPolicy()
^ useful objects

File: Lib/logging/__init__.py
641:1:_defaultFormatter = Formatter()
1156:1:_defaultLastResort = _StderrHandler(WARNING)
1834:1:root = RootLogger(WARNING)

Pattern - dispatch

File: Lib/copyreg.py
10:1:dispatch_table = {}
^ global mutable registry

don’t do I/O at top level to create object
if you really need to have a separate init or setup routine for it

private globals - somewhat different from ones that we want to share
File: Lib/multiprocessing/process.py
363:1:_current_process = _MainProcess()
364:1:_process_counter = itertools.count(1)

File: Lib/pydoc.py
1626:1:text = TextDoc()
1627:1:plaintext = _PlainTextDoc()
1628:1:html = HTMLDoc()
2101:1:help = Helper()

sometimes almost to make up for the lack of builtins

File: Lib/smtpd.py
106:1:DEBUGSTREAM = Devnull()
^ where messages are sent by default; you can replace with NOT:
class Devnull:
    def write(self, msg): pass
    def flush(self): pass

/home/brandon/cpython/Lib/turtledemo/turtle.cfg
8:fillcolor = ""
