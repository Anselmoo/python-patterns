
================
 Module Globals
================

*A “Creational Pattern” inspired by Modula-2 and Modula-3*

.. admonition:: Verdict

   The Module Global pattern is the universal mechanism
   by which a Python module offers functions, classes, constants,
   pre-built objects, and metadata
   for other modules to import.
   This pattern was not available
   in the programming languages considered by the :doc:`/gang-of-four/index`,
   which instead offered only program-wide globals —
   which the Gang of Four condemns as an anti-pattern
   and recommends the Singleton Pattern instead.

.. TODO Add this one I do the singleton:
   Module globals are more common in Python
   than the Gang of Four’s :doc:`gang-of-four/singleton`,
   which was a trick to avoid creating any more global names than necessary
   in languages without the benefit of a module system.

.. TODO mention how for verbs, not nouns, we put methods in the global
   namespace; exmaples are random and json modules

Every Python module is a separate namespace.
Thus, a module like ``json`` can offer a ``loads()`` function
without conflicting with, replacing, or overwriting
the completely different ``loads()`` function
defined over in the ``pickle`` module.

Separate namespaces are crucial to making a programming language tractable.
If Python modules were not separate namespaces,
you would be unable to read or write Python code
by keeping your attention focused on the module in front of you —
a line of code might use, or accidentally conflict with,
a name defined anywhere else in the Standard Library
or a third-party module you have installed.
Programmers forced to code in a language without namespaces
soon find themselves festooning names
with prefixes, suffixes, and extra punctuation
in a desperate race to keep names from conflicting
with similar names defined in other files and libraries.

While every function and class defined in a module is,
technically, an object,
and therefore an example of a Module Global,
the pattern more specifically refers to objects created at the module level
besides those generated by syntactic blocks of code.

Two patterns use Module Globals
but are important enough to have warranted their own articles:

* :doc:`/python/prebound-methods/index`
  are generated when a module builds an object
  and then assigns one or more of the object’s bound methods
  to names at the module’s global level.
  The names can be used to call the methods later
  without needing to know the name of the object itself.

* While a :doc:`/python/sentinel-object/index` is not required
  to live at the module level —
  some sentinel objects are defined as class attributes,
  while others are private and live inside of a closure —
  many sentinels, both in the Standard Library and beyond,
  are defined and accessed as module globals.

This article will cover some other common cases.

.. underscore ForkingPickler = context.reduction.ForkingPickler

Constants
=========

Modules often assign useful numbers, strings, and other values
to names in their global scope.
The Standard Library includes many such assignments,
from which we can excerpt a few examples.

  January = 1                   # calendar
  WARNING = 30                  # logging
  MAX_INTERPOLATION_DEPTH = 10  # configparser
  SSL_HANDSHAKE_TIMEOUT = 60.0  # asyncio.constants
  TICK = "'"                    # email.utils
  CRLF = "\r\n"                 # smtplib

By calling them “constants”
we merely indicate that the objects themselves are immutable.
If you import ``WARNING`` from the ``logging`` module,
the ``int`` object you receive back
will always have the value ``30``.
But always beware that the names themselves are not constants —
the Python language does not protect them from reassignment.

>>> import logging
>>> logging.WARNING = 32
>>> print(logging.WARNING)
32

Constants can also be immutable containers,
like tuples and frozen sets::

  all_errors = (Error, OSError, EOFError)  # ftplib
  bytes_types = (bytes, bytearray)         # pickle
  DIGITS = frozenset("0123456789")         # sre_parse

Even more specialized immutable data types also serve as constants:

  # From the datetime module:
  _EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)

Constants are often introduced as a refactoring:
the programmer notices that the same value ``60.0``
is appearing repeatedly in their code,
and so introduces a constant ``SSL_HANDSHAKE_TIMEOUT``
for the value instead.
Each use will now incur the slight cost of search into the global scope
where an immediate literal value stood before,
but this is balanced by a couple of advantages.
The constant’s name now documents the value’s meaning,
enhancing the code’s readability.
And the constant’s assignment statement
now provides a single location
where the value can be edited in the future
without needing to hunt through the code for each place ``60.0`` was used.

These advantages are weighty enough
that a constant is sometimes introduced
even for a value that’s used only once,
hoisting a literal that was hidden deep in the code
up into visibility as a global.
Some programmers place constant assignments
close to the code that use them,
while others them all at the top of the file.
Unless a constant is placed so close to its code
that it will always be in view of human readers,
it can be more friendly to put constants at the top of the module
for the easy reference of readers
who haven’t yet configured their editors to support jump-to-definition.

Another kind of constant is not directed inwards,
towards the code in the module itself,
but outwards as part of the module’s advertised API.
A constant like ``WARNING`` from the ``logging`` module
offers the advantages of a constant to the caller:
code will be more readable,
and the constant’s value could be adjusted later
without every caller needing to edit their code.

You might expect that a constant intended for the module’s own use,
but not intended for callers,
would always start with an underscore to mark it as private —
but Python programmers are not as consistent in marking constants private
as they are with functions and classes.
After all,
the cost of needing to keep a constant around
because a caller decided to start using it is trivial
compared to the cost of being unable to refactor a private function.



underscore

Sometimes the intention is for these constants to be imported and used,
while in other cases they are solely for the convenience
of the module’s own routines —
in which case you might expect them to start with an underscore,
but Python programmers seem less careful about marking values as private
than they are about marking code.


outside

second: advertised obvious up at top for other programmers
but readability

extreme prog might be happy to say `a = 1` locally
but most folks just want to do the assignment once


sometimes computed
not really:

52:ZIP_FILECOUNT_LIMIT = (1 << 16) - 1

really:

File: Lib/json/encoder.py
34:1:INFINITY = float('inf')

can also be used to avoid recompute “if”:

COPY_BUFSIZE = 1024 * 1024 if _WINDOWS else 16 * 1024

“I could have done that!”

from types.py:
File: Lib/types.py
12:1:FunctionType = type(_f)
LambdaType = type(lambda: None)
File: Lib/_collections_abc.py
36:1:bytes_iterator = type(iter(b''))
37:1:bytearray_iterator = type(iter(bytearray()))
39:1:dict_keyiterator = type(iter({}.keys()))
40:1:dict_valueiterator = type(iter({}.values()))
41:1:dict_itemiterator = type(iter({}.items()))
42:1:list_iterator = type(iter([]))

constant collections
====================

File: Parser/asdl.py
builtin_types = {'identifier', 'string', 'bytes', 'int', 'object', 'singleton',

File: Lib/asyncore.py
60:1:_DISCONNECTED = frozenset({ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE,

Lib/asyncore.py
60:1:_DISCONNECTED = frozenset({ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE,
^ differing levels of effort to make it constant

shutil.py
585:1:_use_fd_functions = ({os.open, os.stat, os.unlink, os.rmdir} <=
                     os.supports_dir_fd and
                     os.scandir in os.supports_fd and
                     os.stat in os.supports_follow_symlinks)
BARELY made sense

Precompiled globals
===================

compile re’s once
File: Lib/glob.py
142:1:magic_check = re.compile('([*?[])')

File: Lib/email/policy.py
23:1:linesep_splitter = re.compile(r'\n|\r')

File: Lib/signal.py
6:1:_globals = globals()

File: Lib/email/header.py
31:1:USASCII = Charset('us-ascii')

File: Lib/re.py
262:1:Pattern = type(sre_compile.compile('', 0))
263:1:Match = type(sre_compile.compile('', 0).match(''))

dunder constants
================

dunder metadata

__all__
__author__
__version__
_ver

File: Lib/unittest/test/testmock/__init__.py
6:1:here = os.path.dirname(__file__)
^ is this anywhere non-test?


File: Lib/xdrlib.py
__all__ = ["Error", "Packer", "Unpacker", "ConversionError"]

File: Lib/__future__.py
50:1:all_feature_names = [
63:1:__all__ = ["all_feature_names"] + all_feature_names
128:1:print_function = _Feature((2, 6, 0, "alpha", 2),
??

not constant at all
not only can you reassign, BUT often not even immutable data structs
why list?
doing tuple for all saves at least 16 bytes? and level of indirection
File: Lib/multiprocessing/context.py
8:1:__all__ = ()

Lib/asyncio/*.py use tuple for all
File: Lib/contextvars.py
4:1:__all__ = ('Context', 'ContextVar', 'Token', 'copy_context')
File: Lib/concurrent/futures/__init__.py
20:1:__all__ = (

File: Lib/tkinter/font.py
6:1:__version__ = "0.9"

File: Lib/turtle.py
103:1:_ver = "turtle 1.1b- - for Python 3.1   -  4. 5. 2009"

but should it be tuple or string?

File: Lib/bz2.py
10:1:__author__ = "Nadeem Vawda <nadeem.vawda@gmail.com>"

__author__ = ("Guido van Rossum <guido@python.org>, "

/home/brandon/cpython/Lib/_collections_abc.py
27:__name__ = "collections.abc"

mutable globals
===============

everything is an object BUT I MEAN:

Pattern - “singleton” object

File: Lib/os.py
759:1:environ = _createenviron()

217:1:default = EmailPolicy()
^ useful objects

File: Lib/logging/__init__.py
641:1:_defaultFormatter = Formatter()
1156:1:_defaultLastResort = _StderrHandler(WARNING)
1834:1:root = RootLogger(WARNING)

Pattern - dispatch

File: Lib/copyreg.py
10:1:dispatch_table = {}
^ global mutable registry

don’t do I/O at top level to create object
if you really need to have a separate init or setup routine for it

private globals - somewhat different from ones that we want to share
File: Lib/multiprocessing/process.py
363:1:_current_process = _MainProcess()
364:1:_process_counter = itertools.count(1)

File: Lib/pydoc.py
1626:1:text = TextDoc()
1627:1:plaintext = _PlainTextDoc()
1628:1:html = HTMLDoc()
2101:1:help = Helper()

sometimes almost to make up for the lack of builtins

File: Lib/smtpd.py
106:1:DEBUGSTREAM = Devnull()
^ where messages are sent by default; you can replace with NOT:
class Devnull:
    def write(self, msg): pass
    def flush(self): pass

/home/brandon/cpython/Lib/turtledemo/turtle.cfg
8:fillcolor = ""
