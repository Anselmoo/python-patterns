
================
 Global Objects
================

*An anti-pattern in the :doc:`/gang-of-four/index`
that Python redeems with per-module global scopes,
inspired by the design of Modula-2 and Modula-3*

.. admonition:: Verdict

   The Global Object pattern is the universal mechanism
   by which each Python module offers functions, classes, constants,
   and general purpose objects for other modules to import.
   This pattern was not available
   in the languages considered by the :doc:`/gang-of-four/index`,
   which suggests the Singleton Pattern instead.

.. TODO Add this one I do the singleton:
   Module globals are more common in Python
   than the Gang of Four’s :doc:`gang-of-four/singleton`,
   which was a trick to avoid creating any more global names than necessary
   in languages without the benefit of a module system.

.. TODO mention how for verbs, not nouns, we put methods in the global
   namespace; exmaples are random and json modules

Every Python module is a separate namespace.
Thus, a module like ``json`` can offer a ``loads()`` function
without conflicting with, replacing, or overwriting
the completely different ``loads()`` function
defined over in the ``pickle`` module.

Separate namespaces are crucial to making a programming language tractable.
If Python modules were not separate namespaces,
you would be unable to read or write Python code
by keeping your attention focused on the module in front of you —
a line of code might use, or accidentally conflict with,
a name defined anywhere else in the Standard Library
or a third-party module you have installed.
Programmers forced to code in a language without namespaces
soon find themselves festooning names
with prefixes, suffixes, and extra punctuation
in a desperate race to keep names from conflicting
with similar names defined in other files and libraries.

While every function and class defined in a module is,
technically, an object,
and therefore an example of a Module Global,
the pattern more specifically refers to objects created at the module level
besides those generated by syntactic blocks of code.

Two patterns use Module Globals
but are important enough to have warranted their own articles:

* :doc:`/python/prebound-methods/index`
  are generated when a module builds an object
  and then assigns one or more of the object’s bound methods
  to names at the module’s global level.
  The names can be used to call the methods later
  without needing to know the name of the object itself.

* While a :doc:`/python/sentinel-object/index` is not required
  to live at the module level —
  some sentinel objects are defined as class attributes,
  while others are private and live inside of a closure —
  many sentinels, both in the Standard Library and beyond,
  are defined and accessed as module globals.

This article will cover some other common cases.

.. underscore ForkingPickler = context.reduction.ForkingPickler

Constants
=========

Modules often assign useful numbers, strings, and other values
to names in their global scope.
The Standard Library includes many such assignments,
from which we can excerpt a few examples.

  January = 1                   # calendar.py
  WARNING = 30                  # logging.py
  MAX_INTERPOLATION_DEPTH = 10  # configparser.py
  SSL_HANDSHAKE_TIMEOUT = 60.0  # asyncio.constants.py
  TICK = "'"                    # email.utils.py
  CRLF = "\r\n"                 # smtplib.py

They are “constants” only in the sense
that the objects themselves are immutable.
The names can still be reassigned.

.. testcode::

   import calendar
   calendar.January = 13
   print(calendar.January)

.. testoutput::

   13

Or deleted, for that matter.

.. testcode::

   del calendar.January
   print(calendar.January)

.. testoutput::

    Traceback (most recent call last):
      ..
    AttributeError: module 'calendar' has no attribute 'January'

In addition to integers, floats, and strings,
values are also crafted from immutable containers like tuples and frozen sets::

  all_errors = (Error, OSError, EOFError)  # ftplib.py
  bytes_types = (bytes, bytearray)         # pickle.py
  DIGITS = frozenset("0123456789")         # sre_parse.py

Even more specialized immutable data types also serve as constants:

  _EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)  # datetime

On rare occasion a module global
which the code clearly intends to never modify
uses a mutable data structure anyway.
Sets are common in code that pre-dates the invention of the ``frozenset``,
while dictionaries are still used today
because, alas, no frozen dictionary exists in Python.

::

  # socket.py
  _blocking_errnos = { EAGAIN, EWOULDBLOCK }

::

  # locale.py
  windows_locale = {
    0x0436: "af_ZA", # Afrikaans
    0x041c: "sq_AL", # Albanian
    0x0484: "gsw_FR",# Alsatian - France
    ...
    0x0435: "zu_ZA", # Zulu
  }

Constants are often introduced as a refactoring:
the programmer notices that the same value ``60.0``
is appearing repeatedly in their code,
and so introduces a constant ``SSL_HANDSHAKE_TIMEOUT``
for the value instead.
Each use will now incur the slight cost of search into the global scope
where an immediate literal value stood before,
but this is balanced by a couple of advantages.
The constant’s name now documents the value’s meaning,
enhancing the code’s readability.
And the constant’s assignment statement
now provides a single location
where the value can be edited in the future
without needing to hunt through the code for each place ``60.0`` was used.

These advantages are weighty enough
that a constant is sometimes introduced
even for a value that’s used only once,
hoisting a literal that was hidden deep in the code
up into visibility as a global.

Some programmers place constant assignments
close to the code that use them,
while others them all at the top of the file.
Unless a constant is placed so close to its code
that it will always be in view of human readers,
it can be more friendly to put constants at the top of the module
for the easy reference of readers
who haven’t yet configured their editors to support jump-to-definition.

Another kind of constant is not directed inwards,
towards the code in the module itself,
but outwards as part of the module’s advertised API.
A constant like ``WARNING`` from the ``logging`` module
offers the advantages of a constant to the caller:
code will be more readable,
and the constant’s value could be adjusted later
without every caller needing to edit their code.

You might expect that a constant intended for the module’s own use,
but not intended for callers,
would always start with an underscore to mark it as private.
But the cost of needing to keep a constant around
because a caller decided to start using it is small
compared to the cost of having a function or class’s API forever locked up,
so Python programmers are not as consistent in marking constants private.

Sometimes constants are introduced for efficiency,
to avoid recomputing a value every time code is called.
Even though math operations involving literal numbers
are in fact pre-computed in all modern Python implementations,
developers often still feel more comfortable
making it explicit that the math should be done at import time
by assignment to a module global::

  # zipfile.py
  ZIP_FILECOUNT_LIMIT = (1 << 16) - 1

When the math expression is complicated,
assigning a name like this can also enhance the code’s readability.

There exist special floating point values
that cannot be written in Python as literals;
they can only be generated by passing a string to the float type.
To avoid calling ``float()`` with ``'nan'`` or ``'inf'``
every single time such a value is needed,
modules often build such values only once as module globals.

::

  # encoder.py
  INFINITY = float('inf')

A constant can also capture the result of a conditional
to avoid re-evaluating it each time the value is needed.

::

  # shutil.py
  COPY_BUFSIZE = 1024 * 1024 if _WINDOWS else 16 * 1024

My favorite example of computed constants in the Standard Library
is the ``types`` module.
I had always assumed it implemented in C,
to gain special access to built-in type objects like ``FunctionType``
and ``LambdaType`` that are defined by the language implementation itself.

It turns out?
I was wrong.

The ``types`` module is written in plain Python.
Without any special access to language internals,
it does what anyone else would have to do
to learn what type functions have.
It creates a function. Then, it asks its type!

::

  # types.py
  def _f(): pass
  FunctionType = type(_f)

On the one hand,
this makes the ``types`` module seem almost superfluous —
you could always use the same trick to discover ``FunctionType`` yourself.
But on the other hand,
importing it from ``types`` lets both major benefits of the constant shine:
code becomes more readable,
because ``FunctionType`` will have the same name everywhere;
and more efficient,
because the constant only needs to be computed once
no matter how many dozen modules in a large system might use it.

.. This might be my favorite constant computation in the Standard Library.
   Not sure it belongs in the text, though.

 _use_fd_functions = ({os.open, os.stat, os.unlink, os.rmdir} <=
                      os.supports_dir_fd and
                      os.scandir in os.supports_fd and
                      os.stat in os.supports_follow_symlinks)

Dunder Constants
================

A special case of constants defined at a module’s global level
are “dunder” constants whose names start and end with double underscores.

Several dunder constants are set by the language itself.
For the official list,
look for the “Modules” subheading in the Python Reference’s section on
`The standard type hierarchy <https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy>`_.
The two encountered most often are ``__name__``,
which programs need to check because of Python’s awful design decision
to assign the fake name ``'__main__'``
to the module invoked from the command line,
and ``__file__``,
the full filesystem path to the module’s Python file itself —
which is almost universally used to find data files included in a package,
even though we the official recommendation these days is to use
`pkgutil.get_data() <https://docs.python.org/3/library/pkgutil.html#pkgutil.get_data>`_
instead.

::

  here = os.path.dirname(__file__)

Beyond the dunder constants set by the language runtime,
there is one Python recognizes if a module chooses to set it:
if ``__all__`` is assigned a sequence of identifiers,
then only those names will be imported into another module
that chooses to ``from … import *`` from the module.
It seems to have appeared more often in the early days of Python
when ``import *`` was popular and not yet recognized as an anti-pattern.

Even though most modules never plan to modify ``__all__``,
they inexplicably specify it as a Python list.
It is more elegant to use a tuple.

Beyond these official dunder constants,
some modules —
despite how many people consider dunder names unattractive —
indulge in the creation of even more.
Assignments to names like ``__author__`` and ``__version__``,
are scattered across the Standard Library and beyond.
While they don’t appear consistently enough
that tooling can assume their presence,
occasional readers probably find them informative,
and they’re easier to get to than official package metadata.

Beware that there does not seem to be agreement,
even within the Standard Library,
about what type ``__author__`` should have.

::

  # bz2.py
  :__author__ = "Nadeem Vawda <nadeem.vawda@gmail.com>"

::

  # inspect.py
  __author__ = ('Ka-Ping Yee <ping@lfw.org>',
                'Yury Selivanov <yselivanov@sprymix.com>')

Why not ``author`` and ``version`` instead?
An early reader probably misread the dunders,
which really meant “special to the Python language,”
as indicating that a value was metadata about the module itself
rather than a useful constant used by its code.

General Global Objects
======================

compile re’s once
File: Lib/glob.py
142:1:magic_check = re.compile('([*?[])')

File: Lib/email/policy.py
23:1:linesep_splitter = re.compile(r'\n|\r')

File: Lib/signal.py
6:1:_globals = globals()

File: Lib/email/header.py
31:1:USASCII = Charset('us-ascii')

File: Lib/re.py
262:1:Pattern = type(sre_compile.compile('', 0))
263:1:Match = type(sre_compile.compile('', 0).match(''))

everything is an object BUT I MEAN:

Pattern - “singleton” object

File: Lib/os.py
759:1:environ = _createenviron()

217:1:default = EmailPolicy()
^ useful objects

File: Lib/logging/__init__.py
641:1:_defaultFormatter = Formatter()
1156:1:_defaultLastResort = _StderrHandler(WARNING)
1834:1:root = RootLogger(WARNING)

Pattern - dispatch

File: Lib/copyreg.py
10:1:dispatch_table = {}
^ global mutable registry

don’t do I/O at top level to create object
if you really need to have a separate init or setup routine for it

private globals - somewhat different from ones that we want to share
File: Lib/multiprocessing/process.py
363:1:_current_process = _MainProcess()
364:1:_process_counter = itertools.count(1)

File: Lib/pydoc.py
1626:1:text = TextDoc()
1627:1:plaintext = _PlainTextDoc()
1628:1:html = HTMLDoc()
2101:1:help = Helper()

sometimes almost to make up for the lack of builtins

File: Lib/smtpd.py
106:1:DEBUGSTREAM = Devnull()
^ where messages are sent by default; you can replace with NOT:
class Devnull:
    def write(self, msg): pass
    def flush(self): pass

/home/brandon/cpython/Lib/turtledemo/turtle.cfg
8:fillcolor = ""
